{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview TF-controller is an experimental controller for Flux to reconcile Terraform resources in the GitOps way. With the power of Flux together with Terraform, TF-controller allows you to GitOps-ify infrastructure, and application resources, in the Kubernetes and Terraform universe, at your own pace. \"At your own pace\" means you don't need to GitOps-ify everything at once. TF-controller offers many GitOps models: 1. GitOps Automation Model: GitOps your Terraform resources from the provision steps to the enforcement steps, like a whole EKS cluster. 2. Hybrid GitOps Automation Model: GitOps parts of your existing infrastructure resources. For example, you have an existing EKS cluster. You can choose to GitOps only its nodegroup, or its security group. 3. State Enforcement Model: You have a TFSTATE file, and you'd like to use GitOps enforce it, without changing anything else. 4. Drift Detection Model: You have a TFSTATE file, and you'd like to use GitOps just for drift detection, so you can decide to do things later when a drift occurs. To get started, follow the getting started guide. Features Multi-Tenancy : TF-controller supports multi-tenancy by running Terraform plan and apply inside Runner Pods. When specifying .metadata.namespace and .spec.serviceAccountName , the Runner Pod uses the specified ServiceAccount and runs inside the specified Namespace. These settings enable the soft multi-tenancy model, which can be used within the Flux multi-tenancy setup. This feature is available since v0.9.0. GitOps Automation for Terraform : With setting .spec.approvePlan=auto , it allows a Terraform object to be reconciled and act as the representation of your Terraform resources. The TF-controller uses the spec of the Terraform object to perform plan , apply its associated Terraform resources. It then stores the TFSTATE of the applied resources as a Secret inside the Kubernetes cluster. After .spec.interval passes, the controller performs drift detection to check if there is a drift occurred between your live system, and your Terraform resources. If a drift occurs, the plan to fix that drift will be generated and applied automatically. This feature is available since v0.3.0. Drift detection : This feature is a part of the GitOps automation feature. The controller detects and fixes drift for your infrastructures, based on the Terraform resources and their TFSTATE . This feature is available since v0.5.0. Drift detection is enabled by default. You can use the field .spec.disableDriftDetection to disable this behaviour. This feature is available since v0.7.0. The Drift detection only mode, without plan or apply steps, allows you to perform read-only drift detection. This feature is available since v0.8.0. Plan and Manual Approve : This feature allows you to separate the plan , out of the apply step, just like the Terraform workflow you are familiar with. A good thing about this is that it is done in a GitOps way. When a plan is generated, the controller shows you a message like 'set approvePlan: \"plan-main-123\" to apply this plan.' . You make change to the field .spec.approvePlan , commit and push to tell the TF-controller to apply the plan for you. With this GitOps workflow, you can optionally create and push this change to a new branch for your team member to review and approve too. This feature is available since v0.6.0. Dependencies Version Terraform Source Controller Flux v2 v0.9.5 v1.1.9 v0.21.2 v0.27.x v0.8.0 v1.1.4 v0.20.1 v0.25.x","title":"Overview"},{"location":"#overview","text":"TF-controller is an experimental controller for Flux to reconcile Terraform resources in the GitOps way. With the power of Flux together with Terraform, TF-controller allows you to GitOps-ify infrastructure, and application resources, in the Kubernetes and Terraform universe, at your own pace. \"At your own pace\" means you don't need to GitOps-ify everything at once. TF-controller offers many GitOps models: 1. GitOps Automation Model: GitOps your Terraform resources from the provision steps to the enforcement steps, like a whole EKS cluster. 2. Hybrid GitOps Automation Model: GitOps parts of your existing infrastructure resources. For example, you have an existing EKS cluster. You can choose to GitOps only its nodegroup, or its security group. 3. State Enforcement Model: You have a TFSTATE file, and you'd like to use GitOps enforce it, without changing anything else. 4. Drift Detection Model: You have a TFSTATE file, and you'd like to use GitOps just for drift detection, so you can decide to do things later when a drift occurs. To get started, follow the getting started guide.","title":"Overview"},{"location":"#features","text":"Multi-Tenancy : TF-controller supports multi-tenancy by running Terraform plan and apply inside Runner Pods. When specifying .metadata.namespace and .spec.serviceAccountName , the Runner Pod uses the specified ServiceAccount and runs inside the specified Namespace. These settings enable the soft multi-tenancy model, which can be used within the Flux multi-tenancy setup. This feature is available since v0.9.0. GitOps Automation for Terraform : With setting .spec.approvePlan=auto , it allows a Terraform object to be reconciled and act as the representation of your Terraform resources. The TF-controller uses the spec of the Terraform object to perform plan , apply its associated Terraform resources. It then stores the TFSTATE of the applied resources as a Secret inside the Kubernetes cluster. After .spec.interval passes, the controller performs drift detection to check if there is a drift occurred between your live system, and your Terraform resources. If a drift occurs, the plan to fix that drift will be generated and applied automatically. This feature is available since v0.3.0. Drift detection : This feature is a part of the GitOps automation feature. The controller detects and fixes drift for your infrastructures, based on the Terraform resources and their TFSTATE . This feature is available since v0.5.0. Drift detection is enabled by default. You can use the field .spec.disableDriftDetection to disable this behaviour. This feature is available since v0.7.0. The Drift detection only mode, without plan or apply steps, allows you to perform read-only drift detection. This feature is available since v0.8.0. Plan and Manual Approve : This feature allows you to separate the plan , out of the apply step, just like the Terraform workflow you are familiar with. A good thing about this is that it is done in a GitOps way. When a plan is generated, the controller shows you a message like 'set approvePlan: \"plan-main-123\" to apply this plan.' . You make change to the field .spec.approvePlan , commit and push to tell the TF-controller to apply the plan for you. With this GitOps workflow, you can optionally create and push this change to a new branch for your team member to review and approve too. This feature is available since v0.6.0.","title":"Features"},{"location":"#dependencies","text":"Version Terraform Source Controller Flux v2 v0.9.5 v1.1.9 v0.21.2 v0.27.x v0.8.0 v1.1.4 v0.20.1 v0.25.x","title":"Dependencies"},{"location":"getting_started/","text":"Getting Started Installation Before using TF-controller, you have to install Flux by using either flux install or flux bootstrap command. After that you can install TF-controller with Flux HelmRelease by: kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml or manually with Helm by: # Add tf-controller helm repository helm repo add tf-controller https://weaveworks.github.io/tf-controller/ # Install tf-controller helm upgrade -i tf-controller tf-controller/tf-controller \\ --namespace flux-system For details on configurable parameters of the TF-controller chart, please see chart readme . Alternatively, you can install TF-controller via kubectl : export TF_CON_VER=v0.10.1 kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.crds.yaml kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.rbac.yaml kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.deployment.yaml Quick start Here's a simple example of how to GitOps your Terraform resources with TF-controller and Flux. Define source First, we need to define a Source controller's source ( GitRepostory , Bucket , OCIRepository ), for example: apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: GitRepository metadata: name: helloworld namespace: flux-system spec: interval: 30s url: https://github.com/tf-controller/helloworld ref: branch: main The GitOps Automation mode The GitOps automation mode could be enabled by setting .spec.approvePlan=auto . In this mode, Terraform resources will be planned, and automatically applied for you. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: interval: 1m approvePlan: \"auto\" path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system For a full list of features and how to use them, follow the use cases guide. Other Examples A Terraform GitOps with Flux to automatically reconcile your AWS IAM Policies . GitOps an existing EKS cluster, by partially import its nodegroup and manage it with TF-controller: An EKS scaling example .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"Before using TF-controller, you have to install Flux by using either flux install or flux bootstrap command. After that you can install TF-controller with Flux HelmRelease by: kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml or manually with Helm by: # Add tf-controller helm repository helm repo add tf-controller https://weaveworks.github.io/tf-controller/ # Install tf-controller helm upgrade -i tf-controller tf-controller/tf-controller \\ --namespace flux-system For details on configurable parameters of the TF-controller chart, please see chart readme . Alternatively, you can install TF-controller via kubectl : export TF_CON_VER=v0.10.1 kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.crds.yaml kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.rbac.yaml kubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.deployment.yaml","title":"Installation"},{"location":"getting_started/#quick-start","text":"Here's a simple example of how to GitOps your Terraform resources with TF-controller and Flux.","title":"Quick start"},{"location":"getting_started/#define-source","text":"First, we need to define a Source controller's source ( GitRepostory , Bucket , OCIRepository ), for example: apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: GitRepository metadata: name: helloworld namespace: flux-system spec: interval: 30s url: https://github.com/tf-controller/helloworld ref: branch: main","title":"Define source"},{"location":"getting_started/#the-gitops-automation-mode","text":"The GitOps automation mode could be enabled by setting .spec.approvePlan=auto . In this mode, Terraform resources will be planned, and automatically applied for you. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: interval: 1m approvePlan: \"auto\" path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system For a full list of features and how to use them, follow the use cases guide.","title":"The GitOps Automation mode"},{"location":"getting_started/#other-examples","text":"A Terraform GitOps with Flux to automatically reconcile your AWS IAM Policies . GitOps an existing EKS cluster, by partially import its nodegroup and manage it with TF-controller: An EKS scaling example .","title":"Other Examples"},{"location":"tfctl/","text":"tfctl tfctl is a command-line utility to help with tf-controller operations. Installation You can download the tfctl binary via the GitHub releases page: https://github.com/weaveworks/tf-controller/releases Usage: tfctl [command] Available Commands: completion Generate the autocompletion script for the specified shell create Create a Terraform resource delete Delete a Terraform resource get Get Terraform resources help Help about any command install Install the tf-controller plan Plan a Terraform configuration reconcile Trigger a reconcile of the provided resource resume Resume reconciliation for the provided resource suspend Suspend reconciliation for the provided resource uninstall Uninstall the tf-controller version Prints tf-controller and tfctl version information Flags: -h, --help help for tfctl --kubeconfig string Path to the kubeconfig file to use for CLI requests. -n, --namespace string The kubernetes namespace to use for CLI requests. (default \"flux-system\") --terraform string The location of the terraform binary. (default \"/usr/bin/terraform\") Use \"tfctl [command] --help\" for more information about a command.","title":"tfctl"},{"location":"tfctl/#tfctl","text":"tfctl is a command-line utility to help with tf-controller operations.","title":"tfctl"},{"location":"tfctl/#installation","text":"You can download the tfctl binary via the GitHub releases page: https://github.com/weaveworks/tf-controller/releases Usage: tfctl [command] Available Commands: completion Generate the autocompletion script for the specified shell create Create a Terraform resource delete Delete a Terraform resource get Get Terraform resources help Help about any command install Install the tf-controller plan Plan a Terraform configuration reconcile Trigger a reconcile of the provided resource resume Resume reconciliation for the provided resource suspend Suspend reconciliation for the provided resource uninstall Uninstall the tf-controller version Prints tf-controller and tfctl version information Flags: -h, --help help for tfctl --kubeconfig string Path to the kubeconfig file to use for CLI requests. -n, --namespace string The kubernetes namespace to use for CLI requests. (default \"flux-system\") --terraform string The location of the terraform binary. (default \"/usr/bin/terraform\") Use \"tfctl [command] --help\" for more information about a command.","title":"Installation"},{"location":"tfe_integration/","text":"Terraform Enterprise Integration Starting from v0.9.5, Weave TF-controller officially supports integration to Terraform Cloud (TFC) and Terraform Enterprise (TFE). Here are the steps to set up TF-controller for your TFE instance. Terraform Login First, you need to obtain an API token from your TFE. You can use terraform login command to do so. terraform login tfe.dev.example.com Then you can find your API token inside $HOME/.terraform.d/credentials.tfrc.json . Content of the file will look like this: { \"credentials\": { \"tfe.dev.example.com\": { \"token\": \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" } } } Prepare an TFRC file TF-controller accepts an TFRC file in the HCL format. So you have to prepare terraform.tfrc file using contents from above. credentials \"tfe.dev.example.com\" { token = \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" } Create a Secret We will now create a Kubernetes Secret from your terraform.tfrc file, name it tfe-cli-config and put it inside the flux-system namespace. kubectl create secret generic \\ tfe-cli-config \\ --namespace=flux-system \\ --from-file=terraform.tfrc=./terraform.tfrc Terraform Object In your Terraform object, you'll have to 1. disable the backend by setting spec.backendConfig.disable: true , and 2. point spec.cliConfigSecretRef: to the Secret created in the previous step, like this: --- apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: tfe-demo namespace: flux-system spec: approvePlan: \"auto\" interval: 2m path: ./terraform/tfe-demo backendConfig: disable: true cliConfigSecretRef: name: tfe-cli-config namespace: flux-system vars: - name: subject value: \"World\" sourceRef: kind: GitRepository name: flux-system namespace: flux-system writeOutputsToSecret: name: tfe-helloworld-output outputs: - greeting Terraform Module Don't forget that you need to tell your Terraform model to use your enterprise instance as well. Here's an example, terraform { required_version = \">= 1.1.0\" cloud { hostname = \"tfe.dev.example.com\" organization = \"weaveworks\" workspaces { name = \"dev\" } } } variable \"subject\" { type = string default = \"World\" description = \"Subject to hello\" } output \"greeting\" { value = \"Hello ${var.subject} from Terraform Enterprise\" } Terraform Cloud For connecting to Terraform Cloud, please replace your hostname to app.terraform.io .","title":"Terraform Enterprise Integration"},{"location":"tfe_integration/#terraform-enterprise-integration","text":"Starting from v0.9.5, Weave TF-controller officially supports integration to Terraform Cloud (TFC) and Terraform Enterprise (TFE). Here are the steps to set up TF-controller for your TFE instance.","title":"Terraform Enterprise Integration"},{"location":"tfe_integration/#terraform-login","text":"First, you need to obtain an API token from your TFE. You can use terraform login command to do so. terraform login tfe.dev.example.com Then you can find your API token inside $HOME/.terraform.d/credentials.tfrc.json . Content of the file will look like this: { \"credentials\": { \"tfe.dev.example.com\": { \"token\": \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" } } }","title":"Terraform Login"},{"location":"tfe_integration/#prepare-an-tfrc-file","text":"TF-controller accepts an TFRC file in the HCL format. So you have to prepare terraform.tfrc file using contents from above. credentials \"tfe.dev.example.com\" { token = \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" }","title":"Prepare an TFRC file"},{"location":"tfe_integration/#create-a-secret","text":"We will now create a Kubernetes Secret from your terraform.tfrc file, name it tfe-cli-config and put it inside the flux-system namespace. kubectl create secret generic \\ tfe-cli-config \\ --namespace=flux-system \\ --from-file=terraform.tfrc=./terraform.tfrc","title":"Create a Secret"},{"location":"tfe_integration/#terraform-object","text":"In your Terraform object, you'll have to 1. disable the backend by setting spec.backendConfig.disable: true , and 2. point spec.cliConfigSecretRef: to the Secret created in the previous step, like this: --- apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: tfe-demo namespace: flux-system spec: approvePlan: \"auto\" interval: 2m path: ./terraform/tfe-demo backendConfig: disable: true cliConfigSecretRef: name: tfe-cli-config namespace: flux-system vars: - name: subject value: \"World\" sourceRef: kind: GitRepository name: flux-system namespace: flux-system writeOutputsToSecret: name: tfe-helloworld-output outputs: - greeting","title":"Terraform Object"},{"location":"tfe_integration/#terraform-module","text":"Don't forget that you need to tell your Terraform model to use your enterprise instance as well. Here's an example, terraform { required_version = \">= 1.1.0\" cloud { hostname = \"tfe.dev.example.com\" organization = \"weaveworks\" workspaces { name = \"dev\" } } } variable \"subject\" { type = string default = \"World\" description = \"Subject to hello\" } output \"greeting\" { value = \"Hello ${var.subject} from Terraform Enterprise\" }","title":"Terraform Module"},{"location":"tfe_integration/#terraform-cloud","text":"For connecting to Terraform Cloud, please replace your hostname to app.terraform.io .","title":"Terraform Cloud"},{"location":"use_cases/","text":"Use Cases The manual mode: plan and manual apply For the plan & manual approval workflow, please either set .spec.approvePlan to be the blank value, or omit the field. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: + approvePlan: \"\" # or you can omit this field - approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system Then the controller will tell you how to use field .spec.approvePlan to approve the plan. After making change and push, it will apply the plan to create real resources. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: hello-world namespace: flux-system spec: + approvePlan: \"plan-main-b8e362c206\" # first 8 digits of a commit hash is enough - approvePlan: \"\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system The drift detection only mode: plan and apply will be skipped To only run drift detection, skipping the plan and apply stages, set .spec.approvePlan to disable . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: hello-world namespace: flux-system spec: approvePlan: \"disable\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system Disable Drift Detection Drift detection is enabled by default. Use the .spec.disableDriftDetection field to disable: apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" disableDriftDetection: true interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system Use with AWS EKS IRSA AWS Elastic Kubernetes Service (EKS) offers IAM Roles for Service Accounts (IRSA) as a mechanism by which to provide credentials to Kubernetes pods. This can be used to provide the required AWS credentials to Terraform runners for performing plans and applies. You can use eksctl to associate an OIDC provider with your EKS cluster, for example: eksctl utils associate-iam-oidc-provider --cluster CLUSTER_NAME --approve Then follow the instructions here to add a trust policy to the IAM role which grants the necessary permissions for Terraform. Please note that if you have installed the controller following the README, then the namespace:serviceaccountname will be flux-system:tf-runner . You'll obtain a Role ARN to use in the next step. Finally, annotate the ServiceAccount for the tf-runner with the obtained Role ARN in your cluster: kubectl annotate -n flux-system serviceaccount tf-runner eks.amazonaws.com/role-arn=ROLE_ARN If deploying the tf-controller via Helm, this can be accomplished as follows: values: runner: serviceAccount: annotations: eks.amazonaws.com/role-arn: ROLE_ARN Setting Terraform Variables This is a breaking change of the v1alpha1 API. Users who are upgrading from TF-controller <= 0.7.0 require updating varsFrom , from a single object: varsFrom: kind: ConfigMap name: cluster-config to be an array of object, like this: varsFrom: - kind: ConfigMap name: cluster-config You can pass variables to Terraform using the vars and varsFrom fields. Inline variables can be set using vars . The varsFrom field accepts a list of ConfigMaps / Secrets. You may use the varsKeys property of varsFrom to select specific keys from the input or omit this field to select all keys from the input source. Note that in the case of the same variable key being passed multiple times, the controller will use the lattermost instance of the key passed to varsFrom . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system vars: - name: region value: us-east-1 - name: env value: dev - name: instanceType value: t3-small varsFrom: - kind: ConfigMap name: cluster-config varsKeys: - nodeCount - instanceType - kind: Secret name: cluster-creds The vars field supports HCL string, number, bool, object and list types. For example, the following variable can be populated using the accompanying Terraform spec: variable \"cluster_spec\" { type = object({ region = string env = string node_count = number public = bool }) } apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system vars: - name: cluster_spec value: region: us-east-1 env: dev node_count: 10 public: false Managing Terraform State By default, tf-controller will use the Kubernetes backend to store the Terraform statefile in cluster. The statefile is stored in a secret named: tfstate-default-${secretSuffix} . The default suffix will be the name of the Terraform resource, however you may override this setting using .spec.backendConfig.secretSuffix . You can disable the backend Use custom backend If you wish to use a custom backend, you can configure it by defining the backendConfig.customConfiguration with one of the backends such as GCS or S3: apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" backendConfig: customConfiguration: | backend \"s3\" { bucket = \"s3-terraform-state1\" key = \"dev/terraform.tfstate\" region = \"us-east-1\" endpoint = \"http://localhost:4566\" skip_credentials_validation = true skip_metadata_api_check = true force_path_style = true dynamodb_table = \"terraformlock\" dynamodb_endpoint = \"http://localhost:4566\" encrypt = true } interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: spec: image: registry.io/tf-runner:xyz Backup the statefile For the following terraform resources: $ kubectl get terraform NAME READY STATUS AGE my-stack Unknown Initializing 28s We can export the state like this: kubectl get secret tfstate-default-my-stack -ojsonpath='{.data.tfstate}' | base64 -d | gzip -d > terraform.tfstate Restore the statefile To restore the statefile or import an existing statefile we can use the following operation: gzip terraform.tfstate NAME=my-stack kubectl create secret \\ generic tfstate-default-${NAME} \\ --from-file=tfstate=terraform.tfstate.gz \\ --dry-run=client -o=yaml \\ | yq e '.metadata.annotations[\"encoding\"]=\"gzip\"' - > tfstate-default-${NAME}.yaml kubectl apply -f tfstate-default-${NAME}.yaml Health Checks For some resources, it may be useful to perform health checks on them to verify that they are ready to accept connection before the terraform goes into Ready state: # main.tf output \"rdsAddress\" { value = \"mydb.xyz.us-east-1.rds.amazonaws.com\" } output \"rdsPort\" { value = \"3306\" } output \"myappURL\" { value = \"https://example.com/\" } apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system healthChecks: - name: rds type: tcp address: \"{{.rdsAddress}}:{{.rdsPort}}\" # uses standard Go package template format to parse outputs to url timeout: 10s # optional, defaults to 20s - name: myapp type: http url: \"{{.myappURL}}\" timeout: 5s - name: url_not_from_output type: http url: \"https://example.org\" Destroy resources on deletion The resources created by terraform are not defaulted to destroyed after the object is deleted from the cluster. To enable destroy resources on object deletion, set .spec.destroyResourcesOnDeletion to true . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" destroyResourcesOnDeletion: true interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system Write outputs to a secret Outputs created by Terraform can be written to a secret using .spec.writeOutputsToSecret . Write all outputs We can specify a target secret, and the controller will write all outputs to the secret by default. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output Write outputs selectively We can choose only a subset of outputs by specify output names we'd like to write in outputs array. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output outputs: - hello_world - my_sensitive_data Output name mapping Some time we'd like to use rename an output, so that it can be consumed by other Kubernetes controllers. For example, we might retrieve a key from a Secret manager, and it's an AGE key, which must be ending with \".agekey\" in the secret. In this case, we need to rename the output. TF-controller supports mapping output name using the \"old_name:new_name\" format. In the following example, we write age_key output as age.agekey entry in the helloworld-output Secret's data. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output outputs: - age_key:age.agekey Customize runner pod Customize runner pod metadata In some situations, it is needed to add custom labels and annotations to the runner pod used to reconcile Terraform. For example, for Azure AKS to grant pod active directory permissions using Azure Active Directory (AAD) Pod Identity, a label like aadpodidbinding: myIdentity on the pod is required. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: metadata: labels: aadpodidbinding: myIdentity annotations: company.com/abc: xyz Customize runner pod image By default, the Terraform controller uses RUNNER_POD_IMAGE environment variable to identify the runner pod image to use. You can customize the image to use on the global level by updating the value of the environment variable or you can specify an image to use per Terraform object for its reconciliation. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: spec: image: registry.io/tf-runner:xyz You can use runner.Dockerfile as a basis of customizing runner pod image. Using OCI Artifact as Source To use OCI artifacts as the source of TF-controller, you need Flux2 version v0.32.0 or higher. Assuming that you have Terraform files (your root module may contain sub-modules) under ./modules, you can use Flux CLI to create an OCI artifact for your Terraform modules by running the following commands: flux push artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\ --path=\"./modules\" \\ --source=\"$(git config --get remote.origin.url)\" \\ --revision=\"$(git branch --show-current)/$(git rev-parse HEAD)\" flux tag artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\ --tag main Then you define a source ( OCIRepository ), and use it as the sourceRef of your Terraform object. --- apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: helloworld-oci spec: interval: 1m url: oci://ghcr.io/tf-controller/helloworld ref: tag: main --- apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld-tf-oci spec: path: ./ approvePlan: \"auto\" interval: 1m sourceRef: kind: OCIRepository name: helloworld-oci writeOutputsToSecret: name: helloworld-outputs","title":"Use Cases"},{"location":"use_cases/#use-cases","text":"","title":"Use Cases"},{"location":"use_cases/#the-manual-mode-plan-and-manual-apply","text":"For the plan & manual approval workflow, please either set .spec.approvePlan to be the blank value, or omit the field. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: + approvePlan: \"\" # or you can omit this field - approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system Then the controller will tell you how to use field .spec.approvePlan to approve the plan. After making change and push, it will apply the plan to create real resources. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: hello-world namespace: flux-system spec: + approvePlan: \"plan-main-b8e362c206\" # first 8 digits of a commit hash is enough - approvePlan: \"\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system","title":"The manual mode: plan and manual apply"},{"location":"use_cases/#the-drift-detection-only-mode-plan-and-apply-will-be-skipped","text":"To only run drift detection, skipping the plan and apply stages, set .spec.approvePlan to disable . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: hello-world namespace: flux-system spec: approvePlan: \"disable\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system","title":"The drift detection only mode: plan and apply will be skipped"},{"location":"use_cases/#disable-drift-detection","text":"Drift detection is enabled by default. Use the .spec.disableDriftDetection field to disable: apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" disableDriftDetection: true interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system","title":"Disable Drift Detection"},{"location":"use_cases/#use-with-aws-eks-irsa","text":"AWS Elastic Kubernetes Service (EKS) offers IAM Roles for Service Accounts (IRSA) as a mechanism by which to provide credentials to Kubernetes pods. This can be used to provide the required AWS credentials to Terraform runners for performing plans and applies. You can use eksctl to associate an OIDC provider with your EKS cluster, for example: eksctl utils associate-iam-oidc-provider --cluster CLUSTER_NAME --approve Then follow the instructions here to add a trust policy to the IAM role which grants the necessary permissions for Terraform. Please note that if you have installed the controller following the README, then the namespace:serviceaccountname will be flux-system:tf-runner . You'll obtain a Role ARN to use in the next step. Finally, annotate the ServiceAccount for the tf-runner with the obtained Role ARN in your cluster: kubectl annotate -n flux-system serviceaccount tf-runner eks.amazonaws.com/role-arn=ROLE_ARN If deploying the tf-controller via Helm, this can be accomplished as follows: values: runner: serviceAccount: annotations: eks.amazonaws.com/role-arn: ROLE_ARN","title":"Use with AWS EKS IRSA"},{"location":"use_cases/#setting-terraform-variables","text":"This is a breaking change of the v1alpha1 API. Users who are upgrading from TF-controller <= 0.7.0 require updating varsFrom , from a single object: varsFrom: kind: ConfigMap name: cluster-config to be an array of object, like this: varsFrom: - kind: ConfigMap name: cluster-config You can pass variables to Terraform using the vars and varsFrom fields. Inline variables can be set using vars . The varsFrom field accepts a list of ConfigMaps / Secrets. You may use the varsKeys property of varsFrom to select specific keys from the input or omit this field to select all keys from the input source. Note that in the case of the same variable key being passed multiple times, the controller will use the lattermost instance of the key passed to varsFrom . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system vars: - name: region value: us-east-1 - name: env value: dev - name: instanceType value: t3-small varsFrom: - kind: ConfigMap name: cluster-config varsKeys: - nodeCount - instanceType - kind: Secret name: cluster-creds The vars field supports HCL string, number, bool, object and list types. For example, the following variable can be populated using the accompanying Terraform spec: variable \"cluster_spec\" { type = object({ region = string env = string node_count = number public = bool }) } apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system vars: - name: cluster_spec value: region: us-east-1 env: dev node_count: 10 public: false","title":"Setting Terraform Variables"},{"location":"use_cases/#managing-terraform-state","text":"By default, tf-controller will use the Kubernetes backend to store the Terraform statefile in cluster. The statefile is stored in a secret named: tfstate-default-${secretSuffix} . The default suffix will be the name of the Terraform resource, however you may override this setting using .spec.backendConfig.secretSuffix . You can disable the backend","title":"Managing Terraform State"},{"location":"use_cases/#use-custom-backend","text":"If you wish to use a custom backend, you can configure it by defining the backendConfig.customConfiguration with one of the backends such as GCS or S3: apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" backendConfig: customConfiguration: | backend \"s3\" { bucket = \"s3-terraform-state1\" key = \"dev/terraform.tfstate\" region = \"us-east-1\" endpoint = \"http://localhost:4566\" skip_credentials_validation = true skip_metadata_api_check = true force_path_style = true dynamodb_table = \"terraformlock\" dynamodb_endpoint = \"http://localhost:4566\" encrypt = true } interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: spec: image: registry.io/tf-runner:xyz","title":"Use custom backend"},{"location":"use_cases/#backup-the-statefile","text":"For the following terraform resources: $ kubectl get terraform NAME READY STATUS AGE my-stack Unknown Initializing 28s We can export the state like this: kubectl get secret tfstate-default-my-stack -ojsonpath='{.data.tfstate}' | base64 -d | gzip -d > terraform.tfstate","title":"Backup the statefile"},{"location":"use_cases/#restore-the-statefile","text":"To restore the statefile or import an existing statefile we can use the following operation: gzip terraform.tfstate NAME=my-stack kubectl create secret \\ generic tfstate-default-${NAME} \\ --from-file=tfstate=terraform.tfstate.gz \\ --dry-run=client -o=yaml \\ | yq e '.metadata.annotations[\"encoding\"]=\"gzip\"' - > tfstate-default-${NAME}.yaml kubectl apply -f tfstate-default-${NAME}.yaml","title":"Restore the statefile"},{"location":"use_cases/#health-checks","text":"For some resources, it may be useful to perform health checks on them to verify that they are ready to accept connection before the terraform goes into Ready state: # main.tf output \"rdsAddress\" { value = \"mydb.xyz.us-east-1.rds.amazonaws.com\" } output \"rdsPort\" { value = \"3306\" } output \"myappURL\" { value = \"https://example.com/\" } apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system healthChecks: - name: rds type: tcp address: \"{{.rdsAddress}}:{{.rdsPort}}\" # uses standard Go package template format to parse outputs to url timeout: 10s # optional, defaults to 20s - name: myapp type: http url: \"{{.myappURL}}\" timeout: 5s - name: url_not_from_output type: http url: \"https://example.org\"","title":"Health Checks"},{"location":"use_cases/#destroy-resources-on-deletion","text":"The resources created by terraform are not defaulted to destroyed after the object is deleted from the cluster. To enable destroy resources on object deletion, set .spec.destroyResourcesOnDeletion to true . apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" destroyResourcesOnDeletion: true interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system","title":"Destroy resources on deletion"},{"location":"use_cases/#write-outputs-to-a-secret","text":"Outputs created by Terraform can be written to a secret using .spec.writeOutputsToSecret .","title":"Write outputs to a secret"},{"location":"use_cases/#write-all-outputs","text":"We can specify a target secret, and the controller will write all outputs to the secret by default. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output","title":"Write all outputs"},{"location":"use_cases/#write-outputs-selectively","text":"We can choose only a subset of outputs by specify output names we'd like to write in outputs array. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output outputs: - hello_world - my_sensitive_data","title":"Write outputs selectively"},{"location":"use_cases/#output-name-mapping","text":"Some time we'd like to use rename an output, so that it can be consumed by other Kubernetes controllers. For example, we might retrieve a key from a Secret manager, and it's an AGE key, which must be ending with \".agekey\" in the secret. In this case, we need to rename the output. TF-controller supports mapping output name using the \"old_name:new_name\" format. In the following example, we write age_key output as age.agekey entry in the helloworld-output Secret's data. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system writeOutputsToSecret: name: helloworld-output outputs: - age_key:age.agekey","title":"Output name mapping"},{"location":"use_cases/#customize-runner-pod","text":"","title":"Customize runner pod"},{"location":"use_cases/#customize-runner-pod-metadata","text":"In some situations, it is needed to add custom labels and annotations to the runner pod used to reconcile Terraform. For example, for Azure AKS to grant pod active directory permissions using Azure Active Directory (AAD) Pod Identity, a label like aadpodidbinding: myIdentity on the pod is required. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: metadata: labels: aadpodidbinding: myIdentity annotations: company.com/abc: xyz","title":"Customize runner pod metadata"},{"location":"use_cases/#customize-runner-pod-image","text":"By default, the Terraform controller uses RUNNER_POD_IMAGE environment variable to identify the runner pod image to use. You can customize the image to use on the global level by updating the value of the environment variable or you can specify an image to use per Terraform object for its reconciliation. apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld namespace: flux-system spec: approvePlan: \"auto\" interval: 1m path: ./ sourceRef: kind: GitRepository name: helloworld namespace: flux-system runnerPodTemplate: spec: image: registry.io/tf-runner:xyz You can use runner.Dockerfile as a basis of customizing runner pod image.","title":"Customize runner pod image"},{"location":"use_cases/#using-oci-artifact-as-source","text":"To use OCI artifacts as the source of TF-controller, you need Flux2 version v0.32.0 or higher. Assuming that you have Terraform files (your root module may contain sub-modules) under ./modules, you can use Flux CLI to create an OCI artifact for your Terraform modules by running the following commands: flux push artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\ --path=\"./modules\" \\ --source=\"$(git config --get remote.origin.url)\" \\ --revision=\"$(git branch --show-current)/$(git rev-parse HEAD)\" flux tag artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\ --tag main Then you define a source ( OCIRepository ), and use it as the sourceRef of your Terraform object. --- apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: helloworld-oci spec: interval: 1m url: oci://ghcr.io/tf-controller/helloworld ref: tag: main --- apiVersion: infra.contrib.fluxcd.io/v1alpha1 kind: Terraform metadata: name: helloworld-tf-oci spec: path: ./ approvePlan: \"auto\" interval: 1m sourceRef: kind: OCIRepository name: helloworld-oci writeOutputsToSecret: name: helloworld-outputs","title":"Using OCI Artifact as Source"},{"location":"References/terraform/","text":"Terraform API reference Packages: infra.contrib.fluxcd.io/v1alpha1 infra.contrib.fluxcd.io/v1alpha1 Resource Types: BackendConfigSpec ( Appears on: TerraformSpec ) BackendConfigSpec is for specifying configuration for Terraform\u2019s Kubernetes backend Field Description disable bool (Optional) Disable is to completely disable the backend configuration. secretSuffix string (Optional) inClusterConfig bool (Optional) customConfiguration string (Optional) configPath string (Optional) labels map[string]string (Optional) BackendConfigsReference ( Appears on: TerraformSpec ) Field Description kind string Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019). name string Name of the configs referent. Should reside in the same namespace as the referring resource. keys []string (Optional) Keys is the data key where a specific value can be found at. Defaults to all keys. optional bool (Optional) Optional marks this BackendConfigsReference as optional. When set, a not found error for the values reference is ignored, but any Key or transient error will still result in a reconciliation failure. CrossNamespaceSourceReference ( Appears on: TerraformSpec ) CrossNamespaceSourceReference contains enough information to let you locate the typed Kubernetes resource object at cluster level. Field Description apiVersion string (Optional) API version of the referent. kind string Kind of the referent. name string Name of the referent. namespace string (Optional) Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference. ForceUnlockEnum ( string alias) ( Appears on: TFStateSpec ) HealthCheck ( Appears on: TerraformSpec ) HealthCheck contains configuration needed to perform a health check after terraform is applied. Field Description name string Name of the health check. type string Type of the health check, valid values are (\u2018tcp\u2019, \u2018http\u2019). If tcp is specified, address is required. If http is specified, url is required. url string (Optional) URL to perform http health check on. Required when http type is specified. Go template can be used to reference values from the terraform output (e.g. https://example.org , {{.output_url}}). address string (Optional) Address to perform tcp health check on. Required when tcp type is specified. Go template can be used to reference values from the terraform output (e.g. 127.0.0.1:8080, {{.address}}:{{.port}}). timeout Kubernetes meta/v1.Duration (Optional) The timeout period at which the connection should timeout if unable to complete the request. When not specified, default 20s timeout is used. PlanStatus ( Appears on: TerraformStatus ) Field Description lastApplied string (Optional) pending string (Optional) isDestroyPlan bool (Optional) isDriftDetectionPlan bool (Optional) ResourceInventory ( Appears on: TerraformStatus ) ResourceInventory contains a list of Kubernetes resource object references that have been applied by a Kustomization. Field Description entries []ResourceRef Entries of Kubernetes resource object references. ResourceRef ( Appears on: ResourceInventory ) ResourceRef contains the information necessary to locate a resource within a cluster. Field Description n string Terraform resource\u2019s name. t string Type is Terraform resource\u2019s type id string ID is the resource identifier. This is cloud-specific. For example, ARN is an ID on AWS. RunnerPodMetadata ( Appears on: RunnerPodTemplate ) Field Description labels map[string]string (Optional) Labels to add to the runner pod annotations map[string]string (Optional) Annotations to add to the runner pod RunnerPodSpec ( Appears on: RunnerPodTemplate ) Field Description image string (Optional) Runner pod image to use other than default envFrom []Kubernetes core/v1.EnvFromSource (Optional) List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. env []Kubernetes core/v1.EnvVar (Optional) List of environment variables to set in the container. Cannot be updated. RunnerPodTemplate ( Appears on: TerraformSpec ) Field Description metadata RunnerPodMetadata (Optional) spec RunnerPodSpec (Optional) image string (Optional) Runner pod image to use other than default envFrom []Kubernetes core/v1.EnvFromSource (Optional) List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. env []Kubernetes core/v1.EnvVar (Optional) List of environment variables to set in the container. Cannot be updated. TFStateSpec ( Appears on: TerraformSpec ) TFStateSpec allows the user to set ForceUnlock Field Description forceUnlock ForceUnlockEnum (Optional) ForceUnlock a Terraform state if it has become locked for any reason. This is an Enum and has the expected values of: auto yes no WARNING: Only use auto in the cases where you are absolutely certain that no other system is using this state, you could otherwise end up in a bad place See https://www.terraform.io/language/state/locking#force-unlock for more information on the terraform state lock and force unlock. lockIdentifier string (Optional) LockIdentifier holds the Identifier required by Terraform to unlock the state if it ever gets into a locked state. You\u2019ll need to put the Lock Identifier in here while setting ForceUnlock to either true or auto . Leave this empty to do nothing, set this to the value of the Lock Info: ID: [value] , e.g. f2ab685b-f84d-ac0b-a125-378a22877e8d , to force unlock the state. Terraform Terraform is the Schema for the terraforms API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec TerraformSpec approvePlan string (Optional) ApprovePlan specifies name of a plan wanted to approve. If its value is \u201cauto\u201d, the controller will automatically approve every plan. destroy bool (Optional) Destroy produces a destroy plan. Applying the plan will destroy all resources. backendConfig BackendConfigSpec (Optional) backendConfigsFrom []BackendConfigsReference (Optional) vars []Variable (Optional) List of input variables to set for the Terraform program. varsFrom []VarsReference (Optional) List of references to a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey. Values of the later Secret / ConfigMap with the same keys will override those of the former. interval Kubernetes meta/v1.Duration The interval at which to reconcile the Terraform. retryInterval Kubernetes meta/v1.Duration (Optional) The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the TerraformSpec.Interval value to retry failures. path string (Optional) Path to the directory containing Terraform (.tf) files. Defaults to \u2018None\u2019, which translates to the root path of the SourceRef. sourceRef CrossNamespaceSourceReference SourceRef is the reference of the source where the Terraform files are stored. suspend bool (Optional) Suspend is to tell the controller to suspend subsequent TF executions, it does not apply to already started executions. Defaults to false. force bool (Optional) Force instructs the controller to unconditionally re-plan and re-apply TF resources. Defaults to false. writeOutputsToSecret WriteOutputsToSecretSpec (Optional) A list of target secrets for the outputs to be written as. disableDriftDetection bool (Optional) Disable automatic drift detection. Drift detection may be resource intensive in the context of a large cluster or complex Terraform statefile. Defaults to false. cliConfigSecretRef Kubernetes core/v1.SecretReference (Optional) healthChecks []HealthCheck (Optional) List of health checks to be performed. destroyResourcesOnDeletion bool (Optional) Create destroy plan and apply it to destroy terraform resources upon deletion of this object. Defaults to false. serviceAccountName string (Optional) Name of a ServiceAccount for the runner Pod to provision Terraform resources. Default to tf-runner. alwaysCleanupRunnerPod bool (Optional) Clean the runner pod up after each reconciliation cycle runnerTerminationGracePeriodSeconds int64 (Optional) Configure the termination grace period for the runner pod. Use this parameter to allow the Terraform process to gracefully shutdown. Consider increasing for large, complex or slow-moving Terraform managed resources. refreshBeforeApply bool (Optional) RefreshBeforeApply forces refreshing of the state before the apply step. runnerPodTemplate RunnerPodTemplate (Optional) enableInventory bool (Optional) EnableInventory enables the object to store resource entries as the inventory for external use. tfstate TFStateSpec (Optional) status TerraformStatus TerraformSpec ( Appears on: Terraform ) TerraformSpec defines the desired state of Terraform Field Description approvePlan string (Optional) ApprovePlan specifies name of a plan wanted to approve. If its value is \u201cauto\u201d, the controller will automatically approve every plan. destroy bool (Optional) Destroy produces a destroy plan. Applying the plan will destroy all resources. backendConfig BackendConfigSpec (Optional) backendConfigsFrom []BackendConfigsReference (Optional) vars []Variable (Optional) List of input variables to set for the Terraform program. varsFrom []VarsReference (Optional) List of references to a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey. Values of the later Secret / ConfigMap with the same keys will override those of the former. interval Kubernetes meta/v1.Duration The interval at which to reconcile the Terraform. retryInterval Kubernetes meta/v1.Duration (Optional) The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the TerraformSpec.Interval value to retry failures. path string (Optional) Path to the directory containing Terraform (.tf) files. Defaults to \u2018None\u2019, which translates to the root path of the SourceRef. sourceRef CrossNamespaceSourceReference SourceRef is the reference of the source where the Terraform files are stored. suspend bool (Optional) Suspend is to tell the controller to suspend subsequent TF executions, it does not apply to already started executions. Defaults to false. force bool (Optional) Force instructs the controller to unconditionally re-plan and re-apply TF resources. Defaults to false. writeOutputsToSecret WriteOutputsToSecretSpec (Optional) A list of target secrets for the outputs to be written as. disableDriftDetection bool (Optional) Disable automatic drift detection. Drift detection may be resource intensive in the context of a large cluster or complex Terraform statefile. Defaults to false. cliConfigSecretRef Kubernetes core/v1.SecretReference (Optional) healthChecks []HealthCheck (Optional) List of health checks to be performed. destroyResourcesOnDeletion bool (Optional) Create destroy plan and apply it to destroy terraform resources upon deletion of this object. Defaults to false. serviceAccountName string (Optional) Name of a ServiceAccount for the runner Pod to provision Terraform resources. Default to tf-runner. alwaysCleanupRunnerPod bool (Optional) Clean the runner pod up after each reconciliation cycle runnerTerminationGracePeriodSeconds int64 (Optional) Configure the termination grace period for the runner pod. Use this parameter to allow the Terraform process to gracefully shutdown. Consider increasing for large, complex or slow-moving Terraform managed resources. refreshBeforeApply bool (Optional) RefreshBeforeApply forces refreshing of the state before the apply step. runnerPodTemplate RunnerPodTemplate (Optional) enableInventory bool (Optional) EnableInventory enables the object to store resource entries as the inventory for external use. tfstate TFStateSpec (Optional) TerraformStatus ( Appears on: Terraform ) TerraformStatus defines the observed state of Terraform Field Description ReconcileRequestStatus github.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus (Members of ReconcileRequestStatus are embedded into this type.) observedGeneration int64 (Optional) ObservedGeneration is the last reconciled generation. conditions []Kubernetes meta/v1.Condition (Optional) lastAppliedRevision string (Optional) The last successfully applied revision. The revision format for Git sources is / . lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. lastPlannedRevision string (Optional) LastPlannedRevision is the revision used by the last planning process. The result could be either no plan change or a new plan generated. lastDriftDetectedAt Kubernetes meta/v1.Time (Optional) LastDriftDetectedAt is the time when the last drift was detected lastAppliedByDriftDetectionAt Kubernetes meta/v1.Time (Optional) LastAppliedByDriftDetectionAt is the time when the last drift was detected and terraform apply was performed as a result availableOutputs []string (Optional) plan PlanStatus (Optional) inventory ResourceInventory (Optional) Inventory contains the list of Terraform resource object references that have been successfully applied. Variable ( Appears on: TerraformSpec ) Field Description name string Name is the name of the variable value Kubernetes pkg/apis/apiextensions/v1.JSON (Optional) valueFrom Kubernetes core/v1.EnvVarSource (Optional) VarsReference ( Appears on: TerraformSpec ) VarsReference contain a reference of a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey. Field Description kind string Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019). name string Name of the values referent. Should reside in the same namespace as the referring resource. varsKeys []string (Optional) VarsKeys is the data key at which a specific value can be found. Defaults to all keys. optional bool (Optional) Optional marks this VarsReference as optional. When set, a not found error for the values reference is ignored, but any VarsKey or transient error will still result in a reconciliation failure. WriteOutputsToSecretSpec ( Appears on: TerraformSpec ) WriteOutputsToSecretSpec defines where to store outputs, and which outputs to be stored. Field Description name string Name is the name of the Secret to be written outputs []string (Optional) Outputs contain the selected names of outputs to be written to the secret. Empty array means writing all outputs, which is default. This page was automatically generated with gen-crd-api-reference-docs","title":"Terraform"}]}